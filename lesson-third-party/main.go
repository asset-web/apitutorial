package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strings"
	"time"
	"math/rand"
	// "io/ioutil"
)

var client *http.Client

const host = "https://quote-garden.herokuapp.com/quotes"
// ref: https://github.com/shevabam/breaking-bad-quotes
const bb_host = "https://breaking-bad-quotes.herokuapp.com"
const port = "8080"

// Quotes is the response type from a search
type Quotes struct {
	Count   int     `json:"count"`
	Results []Quote `json:"results"`
}

// Quote is a quote
type Quote struct {
	// ID          string `json:"_id"`
	QuoteText   string `json:"quoteText"`
	QuoteAuthor string `json:"quoteAuthor"`
}

// BBQuote is a quote
type BBQuote struct {
	QuoteText   string `json:"quote"`
	QuoteAuthor string `json:"author"`
}

// BBQuotes is the response type from Breaking Bad quotes request
type BBQuotes []BBQuote

// type AutoGenerated []struct {
// 	Quote  string `json:"quote"`
// 	Author string `json:"author"`
// }

func (q *Quote) String() string {
	return fmt.Sprintf(`%s
> %s
`, q.QuoteText, q.QuoteAuthor)
}

func (q *BBQuote) String() string {
	return fmt.Sprintf(`%s
> %s
`, q.QuoteText, q.QuoteAuthor)
}

func main() {
	client = http.DefaultClient
	client.Timeout = 10 * time.Second // set a timeout limit of 10 seconds
	http.HandleFunc("/quotes/random", getRandomQuote)
	http.HandleFunc("/quotes/search/", getSearchQuote)
	http.HandleFunc("/bbquotes/random", getRandomBreakingBadQuote)
	addr := fmt.Sprintf(":%s", port)
	log.Printf("running on address: %s", addr)
	http.ListenAndServe(addr, nil)
}

// getRandomQuote gets a random quote from our source
func getRandomQuote(w http.ResponseWriter, r *http.Request) {
	resp, err := client.Get(fmt.Sprintf("%s/random", host))
	if err != nil {
		w.WriteHeader(500)
		w.Write([]byte(fmt.Errorf("getting response: %v", err.Error()).Error()))
		return
	}
	defer resp.Body.Close()
	// io.Copy(w, resp.Body)
	var q Quote
	err = json.NewDecoder(resp.Body).Decode(&q)
	if err != nil {
		w.WriteHeader(500)
		w.Write([]byte(fmt.Errorf("decoding response: %v", err.Error()).Error()))
		return
	}
	w.Write([]byte(q.String()))
}

// getSearchQuote returns a list of quotes
func getSearchQuote(w http.ResponseWriter, r *http.Request) {
	searchTerm := strings.TrimPrefix(r.URL.Path, "/quotes/search/")
	resp, err := client.Get(fmt.Sprintf("%s/search/%s", host, searchTerm))
	if err != nil {
		w.WriteHeader(500)
		w.Write([]byte(fmt.Errorf("getting response: %v", err.Error()).Error()))
		return
	}
	defer resp.Body.Close()
	// io.Copy(w, resp.Body)
	var quotes Quotes
	err = json.NewDecoder(resp.Body).Decode(&quotes)
	if err != nil {
		w.WriteHeader(500)
		w.Write([]byte(fmt.Errorf("decoding response: %v", err.Error()).Error()))
		return
	}
	i := 0
	for _, q := range quotes.Results {
		w.Write([]byte(q.String()))
		i++
		if i > 4 {
			break
		}
	}
}

func getRandomBreakingBadQuote(w http.ResponseWriter, r *http.Request) {
	// Retrieve list of quotes
	resp, err := client.Get(bb_host + "/v1/quotes/5")
	if err != nil {
		w.WriteHeader(500)
		w.Write([]byte(fmt.Errorf("getting response: %v", err.Error()).Error()))
		return
	}

	defer resp.Body.Close()

	// body, err := ioutil.ReadAll(resp.Body)
	// bodyString := string(body)
	// log.Printf(bodyString)

	var quotes BBQuotes
	err = json.NewDecoder(resp.Body).Decode(&quotes)
	if err != nil {
		w.WriteHeader(500)
		w.Write([]byte(fmt.Errorf("decoding response: %v", err.Error()).Error()))
		return
	}

	// Select one by random
	rand.Seed(42)
	q := quotes[rand.Intn(len(quotes))]
	w.Write([]byte(q.String()))

	// Print response
	// for _, q := range quotes.Results {
	// 	w.Write([]byte(q.String()))
	// 	i++
	// 	if i > 4 {
	// 		break
	// 	}
	// }
}